#pragma kernel CSMain
#pragma multi_compile BBOX_CULL_MODE NAIVE_BBOX_CULL_MODE

#include "InstanceData.cginc"

float4x4 _UNITY_MATRIX_MVP;
int _numInstances;

float3 _cameraPos;
float _DistanceLOD0;
float _DistanceLOD1;
float _DistanceLOD2;

RWStructuredBuffer<BBox> bBoxes;
RWStructuredBuffer<int>  visibilityBuffer;

inline uint IsVisibleAfterFrustumCulling(float4 clipPos)
{
    return (clipPos.z >  clipPos.w 
         || clipPos.x < -clipPos.w 
         || clipPos.x >  clipPos.w 
         || clipPos.y < -clipPos.w 
         || clipPos.y >  clipPos.w) 
         ? 0 : 1;
}

inline bool IsAABBIntersects(float3 min1, float3 max1, float3 min2, float3 max2)
{
    return min1.x < max2.x
       &&  max1.x > min2.x
       &&  min1.y < max2.y
       &&  max1.y > min2.y
       &&  min1.z < max2.z
       &&  max1.z > min2.z;
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint)_numInstances)
    {
        BBox bbox = bBoxes[id.x];
        
        float3 minPos = bbox.center - bbox.extents;
        float3 maxPos = bbox.center + bbox.extents;

        float4 boxCorners[8];
        boxCorners[0] = float4(minPos.x, minPos.y, minPos.z, 1.0);
        boxCorners[1] = float4(minPos.x, minPos.y, maxPos.z, 1.0);
        boxCorners[2] = float4(minPos.x, maxPos.y, minPos.z, 1.0);
        boxCorners[3] = float4(minPos.x, maxPos.y, maxPos.z, 1.0);
        boxCorners[4] = float4(maxPos.x, minPos.y, minPos.z, 1.0);
        boxCorners[5] = float4(maxPos.x, minPos.y, maxPos.z, 1.0);
        boxCorners[6] = float4(maxPos.x, maxPos.y, minPos.z, 1.0);
        boxCorners[7] = float4(maxPos.x, maxPos.y, maxPos.z, 1.0);
    
        uint isInFrustum = 0;
#if defined(NAIVE_BBOX_CULL_MODE)
        float4 clipPos = mul(_UNITY_MATRIX_MVP, boxCorners[0]);
        isInFrustum = IsVisibleAfterFrustumCulling(clipPos);
        
        [unroll]
        for (int i = 1; i < 8; i++)
        {
            clipPos = mul(_UNITY_MATRIX_MVP, boxCorners[i]);
            isInFrustum = saturate(isInFrustum + IsVisibleAfterFrustumCulling(clipPos));
        }
#elif defined(BBOX_CULL_MODE)
        float4 corner = mul(_UNITY_MATRIX_MVP, boxCorners[0]);
        float3 frSpCorner = corner.xyz / corner.w;
        float3 screenMinPos = frSpCorner;
        float3 screenMaxPos = frSpCorner;
        
        [unroll]
        for (int i = 1; i < 8; i++)
        {
            corner = mul(_UNITY_MATRIX_MVP, boxCorners[i]);
            frSpCorner = corner.xyz / corner.w;
            screenMinPos = min(screenMinPos, frSpCorner);
            screenMaxPos = max(screenMaxPos, frSpCorner);
        }
        
        isInFrustum = IsAABBIntersects(float3(-1.0f, -1.0f, 0.0f), float3(1.0, 1.0, 1.0f), screenMinPos, screenMaxPos);
#endif
        
        float distance = length(_cameraPos - bbox.center);
        int lod = -1;
        if (isInFrustum == 1)
        {
            if (distance < _DistanceLOD0) {
                lod = 0;
            }
            else if (distance < _DistanceLOD1) {
                lod = 1;
            }
            else if (distance < _DistanceLOD2) {
                lod = 2;
            }
            else {
                lod = 3;
            }
        }
        
        visibilityBuffer[id.x] = lod;
    }
}